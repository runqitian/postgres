-- parent table defintion
CREATE TABLE orders(
    id int,
    name varchar,
    description text,
    price float4,
    quantity int,
    purchase_date date
);

-- ALTER TABLE [ IF EXISTS ] [ ONLY ] name [ * ]
--     action [, ... ]
CREATE TABLE parent_table(
    LIKE orders
);
CREATE TABLE test_only () INHERITS (parent_table);
ALTER TABLE test_only ADD col1 int;
ALTER TABLE IF EXISTS fake_table ADD col2 int;
-- TOFIX: Case 9 in https://quip-amazon.com/lWMEADkOt12v/DDL-Deparser-testing-failed-cases
-- ALTER TABLE IF EXISTS ONLY parent_table ADD PRIMARY KEY (id);
ALTER TABLE IF EXISTS parent_table * ADD CHECK (id > 10);

-- ADD [ COLUMN ] [ IF NOT EXISTS ] column_name data_type [ COLLATE collation ] [ column_constraint [ ... ] ]
CREATE TABLE test_add_column(
    LIKE orders
);
ALTER TABLE test_add_column ADD col1 int;
ALTER TABLE test_add_column ADD COLUMN col2 int;
ALTER TABLE test_add_column ADD COLUMN IF NOT EXISTS col2 varchar;
ALTER TABLE test_add_column ADD col3 varchar COLLATE "fr_FR";
-- TOFIX: Case 8 in https://quip-amazon.com/lWMEADkOt12v/DDL-Deparser-testing-failed-cases
-- ALTER TABLE test_add_column ADD col4 int CHECK (col4 > 100) UNIQUE;
ALTER TABLE test_add_column ADD COLUMN IF NOT EXISTS col5 text COLLATE "es_ES" DEFAULT 'foo' NOT NULL;

-- DROP [ COLUMN ] [ IF EXISTS ] column_name [ RESTRICT | CASCADE ]
CREATE TABLE test_drop_column(
    LIKE orders,
    UNIQUE (id),
    UNIQUE (name)
);
CREATE TABLE foreign_table(
    id int REFERENCES test_drop_column (id),
    name varchar REFERENCES test_drop_column (name)
);
ALTER TABLE test_drop_column DROP price;
ALTER TABLE test_drop_column DROP COLUMN quantity;
-- TOFIX: Case 10 in https://quip-amazon.com/lWMEADkOt12v/DDL-Deparser-testing-failed-cases
-- ALTER TABLE test_drop_column DROP IF EXISTS description RESTRICT;
-- TOFIX: Case 7 in https://quip-amazon.com/lWMEADkOt12v/DDL-Deparser-testing-failed-cases
-- ALTER TABLE test_drop_column DROP IF EXISTS name CASCADE;

-- ALTER [ COLUMN ] column_name [ SET DATA ] TYPE data_type [ COLLATE collation ] [ USING expression ]
CREATE TABLE test_alter_type(
    LIKE orders
);
ALTER TABLE test_alter_type ALTER price TYPE int;
ALTER TABLE test_alter_type ALTER COLUMN purchase_date TYPE text COLLATE "fr_FR";
ALTER TABLE test_alter_type ALTER COLUMN quantity SET DATA TYPE float4;
ALTER TABLE test_alter_type ALTER name TYPE int USING id::integer;


-- ALTER [ COLUMN ] column_name SET DEFAULT expression
CREATE TABLE test_alter_set_default(
    LIKE orders
);
ALTER TABLE test_alter_set_default ALTER price SET DEFAULT 100;
ALTER TABLE test_alter_set_default ALTER COLUMN quantity SET DEFAULT 10;

-- ALTER [ COLUMN ] column_name DROP DEFAULT
CREATE TABLE test_drop_default(
    LIKE orders,
    default_price float4 DEFAULT 10.0,
    default_name varchar DEFAULT 'foo'
);
ALTER TABLE test_drop_default ALTER default_price DROP DEFAULT;
ALTER TABLE test_drop_default ALTER COLUMN default_name DROP DEFAULT;

-- ALTER [ COLUMN ] column_name { SET | DROP } NOT NULL
CREATE TABLE test_set_not_null(
    LIKE orders,
    size int NOT NULL
);
ALTER TABLE test_set_not_null ALTER COLUMN id SET NOT NULL;
ALTER TABLE test_set_not_null ALTER size DROP NOT NULL;

-- ALTER [ COLUMN ] column_name DROP EXPRESSION [ IF EXISTS ]
CREATE TABLE test_drop_expression(
    LIKE orders,
    new_id int GENERATED ALWAYS AS ( 3 * ID ) STORED
);
ALTER TABLE test_drop_expression ALTER new_id DROP EXPRESSION;
ALTER TABLE test_drop_expression ALTER id DROP EXPRESSION IF EXISTS;

-- ALTER [ COLUMN ] column_name ADD GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ]
CREATE TABLE test_add_generated(
    LIKE orders,
    col1 int NOT NULL,
    col2 int NOT NULL,
    col3 int NOT NULL
);
ALTER TABLE test_add_generated ALTER col1 ADD GENERATED ALWAYS AS IDENTITY;
ALTER TABLE test_add_generated ALTER COLUMN col2 ADD GENERATED BY DEFAULT AS IDENTITY;
ALTER TABLE test_add_generated ALTER col3 ADD GENERATED BY DEFAULT AS IDENTITY ( INCREMENT BY 10 );

-- ALTER [ COLUMN ] column_name { SET GENERATED { ALWAYS | BY DEFAULT } | SET sequence_option | RESTART [ [ WITH ] restart ] } [...]
CREATE TABLE test_set_generated(
    id1 int GENERATED BY DEFAULT AS IDENTITY,
    id2 int GENERATED ALWAYS AS IDENTITY,
    id3 int GENERATED ALWAYS AS IDENTITY,
    id4 int GENERATED ALWAYS AS IDENTITY,
    id5 int GENERATED ALWAYS AS IDENTITY,
    id6 int GENERATED ALWAYS AS IDENTITY,
    id7 int GENERATED ALWAYS AS IDENTITY
);
ALTER TABLE test_set_generated ALTER id1 SET GENERATED ALWAYS;
ALTER TABLE test_set_generated ALTER id2 SET GENERATED BY DEFAULT;
ALTER TABLE test_set_generated ALTER id3 SET INCREMENT BY 10;
ALTER TABLE test_set_generated ALTER id4 RESTART;
ALTER TABLE test_set_generated ALTER id5 RESTART WITH 101;
ALTER TABLE test_set_generated ALTER id6 RESTART WITH 201;
ALTER TABLE test_set_generated ALTER COLUMN id7 SET GENERATED BY DEFAULT SET INCREMENT BY 100 RESTART WITH 301;

-- ALTER [ COLUMN ] column_name DROP IDENTITY [ IF EXISTS ]
CREATE TABLE test_drop_identity(
    id int,
    id_generated int GENERATED ALWAYS AS IDENTITY
);
ALTER TABLE test_drop_identity ALTER id_generated DROP IDENTITY;
ALTER TABLE test_drop_identity ALTER id DROP IDENTITY IF EXISTS;

-- ALTER [ COLUMN ] column_name SET STATISTICS integer
CREATE TABLE test_set_statistics(
    LIKE orders
);
ALTER TABLE test_set_statistics ALTER id SET STATISTICS 1;

-- ALTER [ COLUMN ] column_name SET ( attribute_option = value [, ... ] )
CREATE TABLE test_set_attribute(
    LIKE orders
);
ALTER TABLE test_set_attribute ALTER name SET (n_distinct = 102);
ALTER TABLE test_set_attribute ALTER id SET (n_distinct_inherited = 99, n_distinct = 9);

-- ALTER [ COLUMN ] column_name RESET ( attribute_option [, ... ] )
CREATE TABLE test_reset_attribute(
    LIKE orders
);
ALTER TABLE test_reset_attribute ALTER name RESET (n_distinct);
ALTER TABLE test_reset_attribute ALTER id RESET (n_distinct, n_distinct_inherited);

-- ALTER [ COLUMN ] column_name SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
CREATE TABLE test_set_storage(
    LIKE orders,
    product_name text
);
ALTER TABLE test_set_storage ALTER id SET STORAGE PLAIN;
ALTER TABLE test_set_storage ALTER name SET STORAGE EXTERNAL;
ALTER TABLE test_set_storage ALTER description SET STORAGE EXTENDED;
ALTER TABLE test_set_storage ALTER product_name SET STORAGE MAIN;

-- ALTER [ COLUMN ] column_name SET COMPRESSION compression_method
CREATE TABLE test_set_compression(
    LIKE orders
);
ALTER TABLE test_set_compression ALTER name SET COMPRESSION "lz4";
ALTER TABLE test_set_compression ALTER COLUMN description SET COMPRESSION "lz4";

-- ADD table_constraint [ NOT VALID ]
CREATE TABLE test_add_table_constraint(
    LIKE orders
);
-- TOFIX: Case 9 in https://quip-amazon.com/lWMEADkOt12v/DDL-Deparser-testing-failed-cases
-- ALTER TABLE test_add_table_constraint ADD PRIMARY KEY (id);
ALTER TABLE test_add_table_constraint ADD CONSTRAINT max_name_len CHECK (length(name) < 4) NOT VALID;
ALTER TABLE test_add_table_constraint ADD CHECK (id < 10);

-- ADD table_constraint_using_index
CREATE TABLE test_add_constraint_using_index(
    id1 int, 
    id2 int,
    id3 int,
    id4 int,
    id5 int,
    id6 int,
    id7 int
);
-- TOFIX
CREATE UNIQUE INDEX test_add_constraint_used_index1 ON test_add_constraint_using_index (id1);
-- ALTER TABLE test_add_constraint_using_index ADD UNIQUE USING INDEX test_add_constraint_used_index1;
CREATE UNIQUE INDEX test_add_constraint_used_index2 ON test_add_constraint_using_index (id2);
-- ALTER TABLE test_add_constraint_using_index ADD CONSTRAINT primary_constraint_using_index 
--     PRIMARY KEY USING INDEX test_add_constraint_used_index2;
CREATE UNIQUE INDEX test_add_constraint_used_index3 ON test_add_constraint_using_index (id3);
-- ALTER TABLE test_add_constraint_using_index ADD UNIQUE USING INDEX test_add_constraint_used_index3 DEFERRABLE;
CREATE UNIQUE INDEX test_add_constraint_used_index4 ON test_add_constraint_using_index (id4);
-- ALTER TABLE test_add_constraint_using_index ADD UNIQUE USING INDEX test_add_constraint_used_index4 NOT DEFERRABLE;
CREATE UNIQUE INDEX test_add_constraint_used_index5 ON test_add_constraint_using_index (id5);
-- ALTER TABLE test_add_constraint_using_index ADD UNIQUE USING INDEX test_add_constraint_used_index5 INITIALLY DEFERRED;
CREATE UNIQUE INDEX test_add_constraint_used_index6 ON test_add_constraint_using_index (id6);
-- ALTER TABLE test_add_constraint_using_index ADD UNIQUE USING INDEX test_add_constraint_used_index6 INITIALLY IMMEDIATE;
CREATE UNIQUE INDEX test_add_constraint_used_index7 ON test_add_constraint_using_index (id7);
-- ALTER TABLE test_add_constraint_using_index ADD UNIQUE USING INDEX test_add_constraint_used_index7 DEFERRABLE INITIALLY DEFERRED;

-- ALTER CONSTRAINT constraint_name [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
CREATE TABLE test_alter_constraint_referenced(
    id1 int UNIQUE, 
    id2 int UNIQUE,
    id3 int UNIQUE,
    id4 int UNIQUE
);
CREATE TABLE test_alter_constraint(
    id1 int,
    id2 int,
    id3 int,
    id4 int,
    id5 int,
    CONSTRAINT alter_cstr1 FOREIGN KEY (id1) REFERENCES test_alter_constraint_referenced (id1) DEFERRABLE INITIALLY DEFERRED,
    CONSTRAINT alter_cstr2 FOREIGN KEY (id2) REFERENCES test_alter_constraint_referenced (id2) NOT DEFERRABLE,
    CONSTRAINT alter_cstr3 FOREIGN KEY (id3) REFERENCES test_alter_constraint_referenced (id3) DEFERRABLE INITIALLY DEFERRED,
    CONSTRAINT alter_cstr4 FOREIGN KEY (id4) REFERENCES test_alter_constraint_referenced (id4) DEFERRABLE INITIALLY IMMEDIATE
);
-- TOFIX
-- ALTER TABLE test_alter_constraint ALTER CONSTRAINT alter_cstr1 NOT DEFERRABLE;
-- ALTER TABLE test_alter_constraint ALTER CONSTRAINT alter_cstr2 DEFERRABLE;
-- ALTER TABLE test_alter_constraint ALTER CONSTRAINT alter_cstr3 DEFERRABLE INITIALLY IMMEDIATE;
-- ALTER TABLE test_alter_constraint ALTER CONSTRAINT alter_cstr4 DEFERRABLE INITIALLY DEFERRED;

-- VALIDATE CONSTRAINT constraint_name
CREATE TABLE test_validate_constraint(
    LIKE orders
);
ALTER TABLE test_validate_constraint ADD CONSTRAINT test_validate_constraint_cstr CHECK (length(name) < 10) NOT VALID;
-- TOFIX
-- ALTER TABLE test_validate_constraint VALIDATE CONSTRAINT test_validate_constraint_cstr;

-- DROP CONSTRAINT [ IF EXISTS ]  constraint_name [ RESTRICT | CASCADE ]
CREATE TABLE test_drop_constraint(
    LIKE orders,
    CONSTRAINT test_drop_constraint_check CHECK (id < 100),
    CONSTRAINT test_drop_constraint_uniq UNIQUE (id)
);
CREATE TABLE test_drop_constraint_reference(
    id int REFERENCES test_drop_constraint (id),
    name varchar,
    CONSTRAINT test_drop_constraint_reference_cstr1 CHECK (length(name) < 10)
);
ALTER TABLE test_drop_constraint_reference DROP CONSTRAINT test_drop_constraint_reference_cstr1;
ALTER TABLE test_drop_constraint DROP CONSTRAINT test_drop_constraint_check RESTRICT;
-- TOFIX
-- ALTER TABLE test_drop_constraint DROP CONSTRAINT IF EXISTS test_drop_constraint_check RESTRICT;
-- TOFIX
-- ALTER TABLE test_drop_constraint DROP CONSTRAINT test_drop_constraint_uniq CASCADE;

-- TODO: This should be tested with TRIGGER related testing
-- DISABLE TRIGGER [ trigger_name | ALL | USER ]
-- ENABLE TRIGGER [ trigger_name | ALL | USER ]
-- ENABLE REPLICA TRIGGER trigger_name
-- ENABLE ALWAYS TRIGGER trigger_name

-- DISABLE RULE rewrite_rule_name
CREATE TABLE test_disable_rule(
    LIKE orders
);
CREATE RULE sample_rule1 AS
    ON UPDATE TO test_disable_rule
    DO INSTEAD
        SELECT * FROM test_disable_rule;
ALTER TABLE test_disable_rule DISABLE RULE sample_rule1;

-- ENABLE RULE rewrite_rule_name
CREATE TABLE test_enable_rule(
    LIKE orders
);
CREATE RULE sample_rule2 AS
    ON UPDATE TO test_enable_rule
    DO INSTEAD
        SELECT * FROM test_enable_rule;
ALTER TABLE test_enable_rule DISABLE RULE sample_rule2;
ALTER TABLE test_enable_rule ENABLE RULE sample_rule2;

-- ENABLE REPLICA RULE rewrite_rule_name
CREATE TABLE test_enable_replica_rule(
    LIKE orders
);
CREATE RULE sample_rule_enable_replica AS
    ON UPDATE TO test_enable_replica_rule
    DO INSTEAD
        SELECT * FROM test_enable_replica_rule;
ALTER TABLE test_enable_replica_rule ENABLE REPLICA RULE sample_rule_enable_replica;

-- ENABLE ALWAYS RULE rewrite_rule_name
CREATE TABLE test_enable_always_rule(
    LIKE orders
);
CREATE RULE sample_rule_enable_always AS
    ON UPDATE TO test_enable_always_rule
    DO INSTEAD
        SELECT * FROM test_enable_always_rule;
ALTER TABLE test_enable_always_rule ENABLE REPLICA RULE sample_rule_enable_always;

-- DISABLE ROW LEVEL SECURITY
CREATE TABLE test_disable_row_security(
    LIKE orders
);
ALTER TABLE test_disable_row_security DISABLE ROW LEVEL SECURITY;

-- ENABLE ROW LEVEL SECURITY
CREATE TABLE test_enable_row_security(
    LIKE orders
);
ALTER TABLE test_enable_row_security ENABLE ROW LEVEL SECURITY;

-- FORCE ROW LEVEL SECURITY
CREATE TABLE test_force_row_security(
    LIKE orders
);
ALTER TABLE test_force_row_security FORCE ROW LEVEL SECURITY;

-- NO FORCE ROW LEVEL SECURITY
CREATE TABLE test_no_force_row_security(
    LIKE orders
);
ALTER TABLE test_no_force_row_security NO FORCE ROW LEVEL SECURITY;

-- CLUSTER ON index_name
CREATE TABLE test_cluster(
    LIKE orders,
    PRIMARY KEY (id)
);
-- TOFIX
-- ALTER TABLE test_cluster CLUSTER ON test_cluster_pkey;

-- SET WITHOUT CLUSTER
CREATE TABLE test_without_cluster(
    LIKE orders,
    PRIMARY KEY (id)
);
ALTER TABLE test_without_cluster CLUSTER ON test_without_cluster_pkey;
ALTER TABLE test_without_cluster SET WITHOUT CLUSTER;

-- SET WITHOUT OIDS
CREATE TABLE test_set_without_oids(
    LIKE orders
);
ALTER TABLE test_set_without_oids SET WITHOUT OIDS;

-- SET ACCESS METHOD new_access_method
CREATE TABLE test_set_access_method(
    LIKE orders
);
ALTER TABLE test_set_access_method SET ACCESS METHOD heap;

-- SET TABLESPACE new_tablespace
CREATE TABLE test_set_tablespace(
    LIKE orders
);
ALTER TABLE test_set_tablespace SET TABLESPACE pg_default;

-- SET { LOGGED | UNLOGGED }
CREATE TABLE test_set_logged(
    LIKE orders
);
ALTER TABLE test_set_logged SET LOGGED;
CREATE TABLE test_set_unlogged(
    LIKE orders
);
ALTER TABLE test_set_unlogged SET UNLOGGED;

-- SET ( storage_parameter [= value] [, ... ] )
CREATE TABLE test_set_storage_params1(
    LIKE orders
);
ALTER TABLE test_set_storage_params1 SET (vacuum_index_cleanup = ON, autovacuum_vacuum_scale_factor = 0.2, vacuum_truncate = true);
CREATE TABLE test_set_storage_params2(
    LIKE orders
);
ALTER TABLE test_set_storage_params2 SET (vacuum_index_cleanup = ON);

-- RESET ( storage_parameter [, ... ] )
CREATE TABLE test_reset_storage_params1(
    LIKE orders
);
ALTER TABLE test_set_storage_params1 SET (vacuum_index_cleanup = ON, autovacuum_vacuum_scale_factor = 0.2, vacuum_truncate = true);
ALTER TABLE test_reset_storage_params1 RESET (vacuum_index_cleanup, autovacuum_vacuum_scale_factor, vacuum_truncate);
CREATE TABLE test_reset_storage_params2(
    LIKE orders
);
ALTER TABLE test_set_storage_params2 SET (vacuum_index_cleanup = ON);
ALTER TABLE test_reset_storage_params2 RESET (vacuum_index_cleanup);

-- INHERIT parent_table
CREATE TABLE test_inherit_parent(
    parent_id int
);
CREATE TABLE test_inherit_child(
    parent_id int,
    LIKE orders
);
-- TOFIX
-- ALTER TABLE test_inherit_child INHERIT test_inherit_parent;

-- NO INHERIT parent_table
CREATE TABLE test_no_inherit_parent(
    parent_id int
);
CREATE TABLE test_no_inherit_child(
    LIKE orders
) INHERITS (test_no_inherit_parent);
-- TOFIX
-- ALTER TABLE test_no_inherit_child NO INHERIT test_no_inherit_parent;

-- OF type_name
CREATE TYPE test_type_product_type AS (
    id int,
    name varchar
);
CREATE TABLE test_type(
    id int,
    name varchar
);
-- TOFIX
-- ALTER TABLE test_type OF test_type_product_type;

-- NOT OF
CREATE TABLE test_type_not_of OF test_type_product_type;
ALTER TABLE test_type_not_of NOT OF;

-- TODO: This should be tested with ROLE/USER related testing
-- OWNER TO { new_owner | CURRENT_ROLE | CURRENT_USER | SESSION_USER }

-- REPLICA IDENTITY { DEFAULT | USING INDEX index_name | FULL | NOTHING }
CREATE TABLE test_replica_identity1(
    LIKE orders
);
ALTER TABLE test_replica_identity1 REPLICA IDENTITY DEFAULT;
CREATE TABLE test_replica_identity2(
    LIKE orders,
    PRIMARY KEY (id)
);
ALTER TABLE test_replica_identity2 REPLICA IDENTITY USING INDEX test_replica_identity2_pkey;
CREATE TABLE test_replica_identity3(
    LIKE orders
);
ALTER TABLE test_replica_identity3 REPLICA IDENTITY FULL;
CREATE TABLE test_replica_identity4(
    LIKE orders
);
ALTER TABLE test_replica_identity4 REPLICA IDENTITY NOTHING;

-- RENAME [ COLUMN ] column_name TO new_column_name
CREATE TABLE test_alter_col_name(
    LIKE orders
);
ALTER TABLE test_alter_col_name RENAME id TO new_id;
ALTER TABLE test_alter_col_name RENAME COLUMN name TO new_name;

-- RENAME CONSTRAINT constraint_name TO new_constraint_name
CREATE TABLE test_alter_constraint_name(
    LIKE orders,
    CONSTRAINT test_alter_constraint_name_old CHECK (id > 10)
);
ALTER TABLE test_alter_constraint_name RENAME CONSTRAINT test_alter_constraint_name_old TO test_alter_constraint_name_new;

-- RENAME TO new_name
CREATE TABLE test_rename_table(
    LIKE orders
);
ALTER TABLE test_rename_table RENAME to new_test_rename_table;

-- SET SCHEMA new_schema
CREATE TABLE test_set_schema(
    LIKE orders
);
CREATE SCHEMA new_test_schema;
ALTER TABLE test_set_schema SET SCHEMA new_test_schema;

-- ALTER TABLE ALL IN TABLESPACE name [ OWNED BY role_name [, ... ] ]
--     SET TABLESPACE new_tablespace [ NOWAIT ]
-- TOFIX: can not be caught by ddl_command_end event trigger
-- ALTER TABLE ALL IN TABLESPACE pg_default SET TABLESPACE pg_default;
-- ALTER TABLE ALL IN TABLESPACE pg_default OWNED BY ddl_testing_role SET TABLESPACE pg_default;

-- ATTACH PARTITION partition_name { FOR VALUES partition_bound_spec | DEFAULT }
CREATE TABLE test_partition_attach_range(
    LIKE orders
) PARTITION BY RANGE (id);
CREATE TABLE test_partition_attach_range_p_1(
    LIKE test_partition_attach_range
);
-- TOFIX
-- ALTER TABLE test_partition_attach_range ATTACH PARTITION test_partition_attach_range_p_1 DEFAULT;
CREATE TABLE test_partition_attach_range_p_2(
    LIKE test_partition_attach_range
);
-- TOFIX
-- ALTER TABLE test_partition_attach_range ATTACH PARTITION test_partition_attach_range_p_2 FOR VALUES FROM (100) TO (200);
CREATE TABLE test_partition_attach_hash(
    LIKE orders
) PARTITION BY HASH (id);
CREATE TABLE test_partition_attach_hash_p(
    LIKE test_partition_attach_hash
);
-- TOFIX
-- ALTER TABLE test_partition_attach_hash ATTACH PARTITION test_partition_attach_hash_p FOR VALUES WITH (MODULUS 10, REMAINDER 1);
CREATE TABLE test_partition_attach_list(
    LIKE orders
) PARTITION BY LIST (name);
CREATE TABLE test_partition_attach_list_p1(
    LIKE test_partition_attach_list
);
CREATE TABLE test_partition_attach_list_p2(
    LIKE test_partition_attach_list
);
-- TOFIX
-- ALTER TABLE test_partition_attach_list ATTACH PARTITION test_partition_attach_list_p1 FOR VALUES IN ('key1');
-- ALTER TABLE test_partition_attach_list ATTACH PARTITION test_partition_attach_list_p2 FOR VALUES IN ('key2', 'key3');

-- DETACH PARTITION partition_name [ CONCURRENTLY | FINALIZE ]
CREATE TABLE test_detach_partition(
    LIKE orders
) PARTITION BY RANGE (id);
CREATE TABLE test_detach_partition_p1 PARTITION OF test_detach_partition FOR VALUES FROM (1) TO (100);
CREATE TABLE test_detach_partition_p2 PARTITION OF test_detach_partition FOR VALUES FROM (101) TO (200);
CREATE TABLE test_detach_partition_p3 PARTITION OF test_detach_partition FOR VALUES FROM (201) TO (300);
-- TOFIX
-- ALTER TABLE test_detach_partition DETACH PARTITION test_detach_partition_p1;
-- ALTER TABLE test_detach_partition DETACH PARTITION test_detach_partition_p2 CONCURRENTLY;
-- TOFIX: FINALIZE option is not testable
-- ALTER TABLE test_detach_partition DETACH PARTITION test_detach_partition_p3 FINALIZE;


