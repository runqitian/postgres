-- column constraint, index_parameters

-- [ CONSTRAINT constraint_name ]
-- { NOT NULL |
CREATE TABLE col_cstr_not_null(
    id int CONSTRAINT id_constraint NOT NULL,
    name varchar
);

--  NULL |
CREATE TABLE col_cstr_null(
    id int NULL,
    name varchar CONSTRAINT name_constraint NOT NULL
);

--  CHECK ( expression ) [ NO INHERIT ] |
CREATE TABLE col_cstr_check(
    id int CHECK (id > 10),
    name varchar NOT NULL
);
CREATE TABLE col_cstr_check_no_inherit(
    id int CHECK (id > 10) NO INHERIT,
    name varchar NOT NULL
);

--  DEFAULT default_expr |
CREATE TABLE col_cstr_default(
    id int NOT NULL,
    name varchar DEFAULT 'foo'
);

--  GENERATED ALWAYS AS ( generation_expr ) STORED |
CREATE TABLE col_cstr_generated_always_as(
    id int NOT NULL,
    id_generated int GENERATED ALWAYS AS ( id * 10 ) STORED
);

--  GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY [ ( sequence_options ) ] |
CREATE TABLE col_cstr_generated_always_as_identity(
    id int NOT NULL,
    id_generated int GENERATED ALWAYS AS IDENTITY
);
CREATE TABLE col_cstr_generated_by_default_as_identity_with_options(
    id int NOT NULL,
    id_generated int GENERATED BY DEFAULT AS IDENTITY ( INCREMENT BY 10 )
);

--  UNIQUE [ NULLS [ NOT ] DISTINCT ] |
CREATE TABLE col_cstr_unique(
    id int NOT NULL,
    name varchar UNIQUE
);
CREATE TABLE col_cstr_unique_nulls_distinct(
    id int NOT NULL,
    name varchar UNIQUE NULLS DISTINCT
);
CREATE TABLE col_cstr_unique_nulls_not_distinct(
    id int NOT NULL,
    name varchar UNIQUE NULLS NOT DISTINCT
);

--  PRIMARY KEY |
CREATE TABLE col_cstr_primary_key(
    id int PRIMARY KEY,
    name varchar UNIQUE
);

--  REFERENCES reftable [ ( refcolumn ) ] [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
--    [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }
CREATE TABLE col_cstr_reference_table_default(
    id int REFERENCES col_cstr_primary_key,
    name varchar
);
CREATE TABLE col_cstr_reference_table_column(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name)
);
-- [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]
-- skip testing MATCH PARTIAL, which is treated as a syntax error with message
-- ERROR:  MATCH PARTIAL not yet implemented
CREATE TABLE col_cstr_reference_table_column_match_full(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) MATCH FULL
);
CREATE TABLE col_cstr_reference_table_column_match_simple(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) MATCH SIMPLE
);

-- [ ON DELETE referential_action ] 
CREATE TABLE col_cstr_reference_table_column_on_delete_no_action(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON DELETE NO ACTION
);
CREATE TABLE col_cstr_reference_table_column_on_delete_restrict(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON DELETE RESTRICT
);
CREATE TABLE col_cstr_reference_table_column_on_delete_cascade(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON DELETE CASCADE
);
CREATE TABLE col_cstr_reference_table_column_on_delete_set_null(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON DELETE SET NULL
);
CREATE TABLE col_cstr_reference_table_column_on_delete_set_null_with_column(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON DELETE SET NULL (name),
    foo varchar REFERENCES col_cstr_primary_key (name) ON DELETE SET NULL (foo)
);
CREATE TABLE col_cstr_reference_table_column_on_delete_set_default(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON DELETE SET DEFAULT
);
CREATE TABLE col_cstr_reference_table_column_on_delete_set_default_with_col(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON DELETE SET DEFAULT (name)
);

-- [ ON UPDATE referential_action ]
CREATE TABLE col_cstr_reference_table_column_on_update_no_action(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON UPDATE NO ACTION
);
CREATE TABLE col_cstr_reference_table_column_on_update_restrict(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON UPDATE RESTRICT
);
CREATE TABLE col_cstr_reference_table_column_on_update_cascade(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON UPDATE CASCADE
);
CREATE TABLE col_cstr_reference_table_column_on_update_set_null(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON UPDATE SET NULL
);
CREATE TABLE col_cstr_reference_table_column_on_update_set_default(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) ON UPDATE SET DEFAULT
);
-- complex combinations
CREATE TABLE col_cstr_reference_table_column_complex_combination1(
    id int,
    name varchar REFERENCES col_cstr_primary_key (name) MATCH FULL ON DELETE NO ACTION ON UPDATE NO ACTION
);
CREATE TABLE col_cstr_reference_table_column_complex_combination2(
    id int REFERENCES col_cstr_primary_key MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET NULL,
    name varchar
);

-- [ DEFERRABLE | NOT DEFERRABLE ]
CREATE TABLE col_cstr_deferable(
    id int,
    name varchar UNIQUE DEFERRABLE
);
CREATE TABLE col_cstr_not_deferable(
    id int PRIMARY KEY NOT DEFERRABLE,
    name varchar
);

-- [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
CREATE TABLE col_cstr_initially_deferred(
    id int PRIMARY KEY INITIALLY DEFERRED,
    name varchar
);
CREATE TABLE col_cstr_initially_immediate(
    id int,
    name varchar UNIQUE INITIALLY IMMEDIATE
);

-- complex combination
CREATE TABLE col_cstr_complex_combination(
    id int,
    name varchar CONSTRAINT name_constraint REFERENCES col_cstr_primary_key (name) MATCH FULL ON DELETE SET DEFAULT ON UPDATE SET NULL NOT DEFERRABLE INITIALLY IMMEDIATE
);

-- part 4: table constraints
-- [ CONSTRAINT constraint_name ]
-- { CHECK ( expression ) [ NO INHERIT ] |
CREATE TABLE tbl_cstr_check_1(
    CONSTRAINT id_constraint CHECK (id > 10),
    id int,
    name varchar
);
CREATE TABLE tbl_cstr_check_2(
    id int,
    name varchar,
    CONSTRAINT table_check CHECK (id > 10) NO INHERIT
);
CREATE TABLE tbl_cstr_check_no_inherit(
    id int,
    name varchar,
    CHECK (id > 10) NO INHERIT
);

--   UNIQUE [ NULLS [ NOT ] DISTINCT ] ( column_name [, ... ] ) [ INCLUDE ( column_name [, ...]) ] |
CREATE TABLE tbl_cstr_unique(
    id int,
    name varchar,
    UNIQUE (id)
);
CREATE TABLE tbl_cstr_unique_multicols(
    id int,
    name varchar,
    UNIQUE (id, name)
);
CREATE TABLE tbl_cstr_unique_nulls_distinct(
    id int,
    name varchar,
    UNIQUE NULLS DISTINCT (id)
);
CREATE TABLE tbl_cstr_unique_nulls_not_distinct(
    id int,
    name varchar,
    UNIQUE NULLS NOT DISTINCT (id, name)
);
CREATE TABLE tbl_cstr_unique_nulls_distinct_include(
    id int,
    name varchar,
    UNIQUE NULLS DISTINCT (id) INCLUDE (name)
);
CREATE TABLE tbl_cstr_unique_nulls_distinct_include_multi(
    id int,
    name varchar,
    info varchar,
    UNIQUE NULLS DISTINCT (id) INCLUDE (name, info)
);

-- PRIMARY KEY ( column_name [, ... ] ) [ INCLUDE ( column_name [, ...]) ] |
CREATE TABLE tbl_cstr_primary_key(
    id int,
    name varchar,
    PRIMARY KEY (id)
);
CREATE TABLE tbl_cstr_primary_key_multicols(
    id int,
    name varchar,
    PRIMARY KEY (id, name)
);
CREATE TABLE tbl_cstr_primary_key_include(
    id int,
    name varchar,
    PRIMARY KEY (id) INCLUDE (name)
);
CREATE TABLE tbl_cstr_primary_key_include_multicols(
    id int,
    name varchar,
    info varchar,
    PRIMARY KEY (id) INCLUDE (name, info)
);

--   EXCLUDE [ USING index_method ] ( exclude_element WITH operator [, ... ] ) index_parameters [ WHERE ( predicate ) ] |
CREATE TABLE tbl_cstr_exclude(
    id int,
    name varchar,
    EXCLUDE (name WITH =)
);
CREATE TABLE tbl_cstr_exclude_multi(
    id int,
    name varchar,
    EXCLUDE ((id*10) with =, name WITH =)
);
CREATE TABLE tbl_cstr_exclude_index_method(
    id int,
    name varchar,
    EXCLUDE USING btree ((id*10) with =, name WITH =)
);
-- [ INCLUDE ( column_name [, ... ] ) ]
CREATE TABLE tbl_cstr_exclude_with_index_params_include_1(
    id int,
    name varchar,
    EXCLUDE (id WITH =) INCLUDE (name)
);
CREATE TABLE tbl_cstr_exclude_with_index_params_include_2(
    id int,
    name varchar,
    EXCLUDE (id WITH =) INCLUDE (id, name)
);
-- [ WITH ( storage_parameter [= value] [, ... ] ) ]
CREATE TABLE tbl_cstr_exclude_with_index_params_storage_1(
    id int,
    name varchar,
    EXCLUDE (id WITH =) WITH (fillfactor = 20)
);
CREATE TABLE tbl_cstr_exclude_with_index_params_storage_2(
    id int,
    name varchar,
    EXCLUDE (id WITH =) WITH (fillfactor = 20, deduplicate_items = false)
);
-- [ USING INDEX TABLESPACE tablespace_name ]
CREATE TABLE tbl_cstr_exclude_with_index_params_tablespace(
    id int,
    name varchar,
    EXCLUDE (id WITH =) USING INDEX TABLESPACE pg_default
);
-- index_parameters complex combination
CREATE TABLE tbl_cstr_exclude_with_index_params_complex(
    id int,
    name varchar,
    EXCLUDE (id WITH =) INCLUDE (id, name) WITH (fillfactor = 20, deduplicate_items = false) USING INDEX TABLESPACE pg_default
);
-- [ WHERE ( predicate ) ]
CREATE TABLE tbl_cstr_exclude_with_predicate(
    id int,
    name varchar,
    EXCLUDE (id WITH =) WHERE (name<>'foo')
);
-- complex combination for table constraint clauses
CREATE TABLE tbl_cstr_exclude_complex_combination(
    id int,
    name varchar,
    EXCLUDE USING btree (id WITH =, name WITH =) INCLUDE (id, name) WITH (fillfactor = 20, deduplicate_items = false) USING INDEX TABLESPACE pg_default WHERE (name<>'foo')
);

-- FOREIGN KEY ( column_name [, ... ] ) REFERENCES reftable [ ( refcolumn [, ... ] ) ]
--     [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] [ ON DELETE referential_action ] [ ON UPDATE referential_action ] }
CREATE TABLE tbl_cstr_foreign_table(
    id int PRIMARY KEY,
    name varchar UNIQUE,
    UNIQUE (id, name)
);
CREATE TABLE tbl_cstr_foreign_key_simple_1(
    id int,
    name varchar,
    FOREIGN KEY (id) REFERENCES tbl_cstr_foreign_table
);
CREATE TABLE tbl_cstr_foreign_key_simple_2(
    id int,
    name varchar,
    FOREIGN KEY (id) REFERENCES tbl_cstr_foreign_table(id)
);
CREATE TABLE tbl_cstr_foreign_key_multiple_keys(
    id int,
    name varchar,
    FOREIGN KEY (id, name) REFERENCES tbl_cstr_foreign_table (id, name)
);

-- some combinations from REFERENCES clause, which is already tested in part 3
CREATE TABLE tbl_cstr_reference_table_complex_combination1(
    id int,
    name varchar,
    FOREIGN KEY (name) REFERENCES tbl_cstr_foreign_table (name) MATCH SIMPLE ON DELETE CASCADE ON UPDATE SET NULL
);
CREATE TABLE tbl_cstr_reference_table_complex_combination2(
    id int,
    name varchar,
    CONSTRAINT tbl_cstr FOREIGN KEY (id, name) REFERENCES tbl_cstr_foreign_table (id, name) ON DELETE SET NULL (id, name) ON UPDATE SET DEFAULT
);

-- [ DEFERRABLE | NOT DEFERRABLE ]
CREATE TABLE tbl_cstr_reference_table_column_deferable(
    id int,
    name varchar,
    UNIQUE (id, name) DEFERRABLE
);
CREATE TABLE tbl_cstr_reference_table_column_not_deferable(
    id int,
    name varchar,
    PRIMARY KEY (id) NOT DEFERRABLE
);

-- [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
CREATE TABLE tbl_cstr_reference_table_column_initially_deferred(
    id int,
    name varchar,
    UNIQUE (id, name) INITIALLY DEFERRED
);
CREATE TABLE tbl_cstr_reference_table_column_initially_immediate(
    id int,
    name varchar,
    PRIMARY KEY (id) INITIALLY IMMEDIATE
);

-- complex combinations
CREATE TABLE tbl_cstr_reference_table_column_complex_combination1(
    id int,
    name varchar,
    CONSTRAINT tbl_cstr FOREIGN KEY (name) REFERENCES tbl_cstr_foreign_table (name) MATCH FULL ON DELETE NO ACTION ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED
);
CREATE TABLE tbl_cstr_reference_table_column_complex_combination2(
    id int,
    name varchar,
    CONSTRAINT tbl_cstr PRIMARY KEY (id, name) NOT DEFERRABLE INITIALLY IMMEDIATE
);
